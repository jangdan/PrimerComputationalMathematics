---
redirect_from:
  - "/coding/arrays"
interact_link: notebooks/coding/Arrays.ipynb
kernel_name: python3
kernel_path: notebooks/coding
has_widgets: false
title: |-
  Arrays
pagenum: 5
prev_page:
  url: /coding/intro.html
next_page:
  url: /coding/For_loops.html
suffix: .ipynb
search: array lists list arrays numpy not numbers row x python dimensional nested vector only element column using vectors very operations function indexing slicing new memory data example store say e matrix construct three work just simple columns equal similar indexed appending constructing appropriate structures represent rows indices further four multi achieved while fine intuitive complicated scaling much reasons include loops ways create g barray rather length our actually require b j does works where whole reshape needs possible lets want available size input functions section review methods complex simplest storing wanted above characterised index marks increase get hyper cases any

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /notebooks***"
---

    <main class="jupyter-page">
    <div id="page-info"><div id="page-title">Arrays</div>
</div>
    
<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Vectors-and-arrays">Vectors and arrays<a class="anchor-link" href="#Vectors-and-arrays"> </a></h1><p>This section will review the methods of constructing appropriate data structures in python to represent vectors, or more complex arrays.</p>
<p>The simplest way of storing a vector in python is with the use of lists. For example, if we wanted to store a row vector $a = (7, 3, 8, 11)$</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[7, 3, 8, 11]
4
[7, 3, 8, 11, 7, 3, 8, 11, 7, 3, 8, 11, 7, 3, 8, 11, 7, 3, 8, 11]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We say that vectors like the one above are a one-dimensional array of numbers, i.e. it only has one row so each element is characterised by one index which marks the column that it is in. If we were to increase the number of rows we would get a matrix, or a two-dimensional array, which then has 2 indices: one for the row number and one for the column number. We could further construct a three-, four-, and further hyper-dimensional arrays. Constructing multi-dimensional arrays can be achieved by nested lists.</p>
<p>While lists may work just fine for very simple cases, any manipulation of vectors stored as lists soon becomes counter-intuitive and complicated. Even scaling a vector is not as simple as we would like it to be.</p>
<p>It is almost always much more appropriate to use Numerical Python (NumPy) arrays to represent this kind of data structures. There are several reasons for this and they include faster computation time, operations on array without loops, and others.</p>
<p>There are many ways that we can construct NumPy arrays. One is to create an array from existing data, e.g. by using NumPy's array() function on a list.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="c1"># Creates an array based on the list b</span>
<span class="n">b_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="nb">print</span><span class="p">(</span><span class="n">b_array</span><span class="p">)</span>

<span class="c1"># Creates an array based on a new list</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[ 3  5 17]
 [ 1  0  6]
 [ 5  3  0]]
[0 6 7]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Notice how b_array is now automatically formatted as a 3x3 matrix, rather than a nested list (in this case one big list containing three smaller lists). This would not have happened if all the columns and rows did not have equal length.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[list([1, 6, 4]) list([3, 8, 1, 1]) list([4, 0, 3]) list([7, 4, 2])]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that now our array a, rather than consisting only of numbers, actually consists of four lists. This is because three lists have 3 columns, while one has 4. NumPy arrays require that all column and row lengths are equal.</p>
<h3 id="Indexing-and-slicing">Indexing and slicing<a class="anchor-link" href="#Indexing-and-slicing"> </a></h3><p>Indexing an array is very similar to indexing a list or nested lists. A nested list b is indexed as b[i][j], which will work on an array as well, b_array[i][j]. Arrays can be indexed in an additional way, by using only one pair of square brackets and separating the indices by a comma. This does not work on lists, as nested lists are indexed list by list.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Second element in the first list</span>

<span class="nb">print</span><span class="p">(</span><span class="n">b_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># First row, second column in the array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>5
5
5
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Array slicing works in a similar way to list slicing, but is more intuitive. Elements in nested lists have to be considered as a multi-level structure, where an element is in one list, but that whole list is then an element of another list, and so on. This makes indexing and slicing more complicated for lists than it is for arrays.</p>
<p>Let us construct a two-dimensional array (a matrix) using numpy.arange() function.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>  <span class="c1"># Constructs an array with integer values from 0 to 15</span>

<span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We created a one-dimensional array with 16 numbers, which we can now reshape using the reshape() function into a 4x4 array. Remember that the column and row length in each row or column vector in the array needs to be equal. That means that the only possible shapes of our array are 1x16, 2x8, 4x4, 8x2 and 16x1.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's say we want to take a slice of this array that does not include the first and last row and the first two columns. In arrays, this is much more easily achieved, using the same [start:stop:step] formatting, like in lists.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[ 6  7]
 [10 11]]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Pros-and-cons">Pros and cons<a class="anchor-link" href="#Pros-and-cons"> </a></h3><p>One of the reasons behind the speed of NumPy operations is that many of them are not actually implemented in python, but in C, Fortran, and other more efficient languages. However, this comes at a price, and some very handy options available for lists are not available for NumPy arrays.</p>
<p>For example, appending is not possible for NumPy arrays like it is for python lists. Let's say you have a list of 5 numbers and you want to append 3 more numbers to that list. What happens is that the computer has to allocate new memory to store those 8 numbers. When it allocated that memory space, it copies the 5 numbers from the list in the new array (memory) and then assigns the new 3 numbers to the other 3 positions in the array. Althought potentially very computationally expensive, this is just fine in python. The way that NumPy works is that NumPy immediately reserves just enough memory that it needs to store the array of the specified size, so the size of the array cannot be changed. There are, of course, ways of achieving a similar thing like appending to a list (e.g. numpy.concatenate() function), but they are not as user-friendly as list appending.</p>
<h3 id="Operations-on-arrays">Operations on arrays<a class="anchor-link" href="#Operations-on-arrays"> </a></h3>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Mathematical operations on arrays, unlike on lists, do not require loops but are instead performed on the entire array. This is called <strong>vectorisation</strong>. For example, scaling a vector is now as simple as:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># Creates an array of 10 elements, evenly spaced from 0 to 9</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;v = &#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;2v = &#39;</span><span class="p">,</span> <span class="n">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>v =  [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
2v =  [ 0.  2.  4.  6.  8. 10. 12. 14. 16. 18.]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Furthermore, we are able to input the whole array as an argument to functions, such as numpy.sin, which will create a new array where each element is the sinus of a corresponding element in the input array.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sin_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sin_array</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427
 -0.2794155   0.6569866   0.98935825  0.41211849]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This is not limited only to numpy functions.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mf">0.5</span>

<span class="n">sqrt_array</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sqrt_array</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[0.         1.         1.41421356 1.73205081 2.         2.23606798
 2.44948974 2.64575131 2.82842712 3.        ]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

 


    </main>
    